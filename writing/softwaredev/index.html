<!DOCTYPE html><script>(function(){const dates = [{"timestamp":"2024-10-18","headline":"Finding a problem to solve","content":"&lt;p&gt;Software does not hold value in and of itself. This may be an unpleasant truth for those who like to write code, but software needs to add value to the lives of people to use it for it to become a successful software product. There is nothing wrong with hobby projects either, but even if you are the only user, it still need to add value for you.&lt;br/&gt;&lt;br/&gt;Making sure your product solves a problem is the key starting point for a software product. And also where people often get stuck.&lt;br/&gt;&lt;br/&gt;The most successful software products I’ve seen almost start themselves - there is a problem causing enough pain that people seek out a solution, talk to people who can make software, and they work together to solve the problem.&lt;br/&gt;&lt;br/&gt;But those people probably aren’t reading this - you are probably seeking the opposite origin story for your product, that you want to build and operate a software business, but need to go find that idea.&lt;br/&gt;&lt;br/&gt;The best way to make that work is to force the situation where you fix a pain point. Go out and talk to people who work in industries that interest you. Ask them where they feel frustration in their days, and which of those problems causes financial burdens to their company. Then see if you can envision a software product that resolves it.&lt;br/&gt;Be careful to actually be solving the problem with software, and not masking a process re-engineering effort by putting software over top of it. Many problems in business are due to poor processes or communication, and software can solve those. But you need to ask yourself if the same process or communications improvements can be done without software. If they can, your product is just a shiny layer on top of the actual fix, and some day in the future someone can easily get rid of your product.&lt;br/&gt;&lt;br/&gt;&lt;em&gt;Side Note: Entertainment is a valid problem to solve. Video games are software, as are streaming services, chat apps, and other apps that don’t solve business problems but do make people more satisfied with their lives.&lt;/em&gt;&lt;br/&gt;&lt;br/&gt;Software adds value when it does things people are not great at - collecting data, visualizing data, synthesizing data. Automating processes and tasks, organizing incoming requests.&lt;br/&gt;&lt;br/&gt;One way to make sure your software has intrinsic value is to make sure you can specify its inputs and outputs, and that your customers are willing to pay a fee for the process of turning those inputs into those outputs. If you cannot abstract what your software does into an input, output and a financial transaction in exchange for that conversion, you might not have a viable software product.&lt;br/&gt;&lt;br/&gt;Another path is to find a product that has already solved a problem, but done it poorly. Find software that is critical to an industry, but disliked because it is not good software. Then simply do a better job than they did.&lt;br/&gt;&lt;br/&gt;Don’t discount your own problems, either. Write software for just yourself, if it makes your own life better. Then ask around and see if anyone else has the same problem and might want to try your solution.&lt;br/&gt; &lt;br/&gt; &lt;br/&gt; &lt;br/&gt; &lt;/p&gt;","media":null,"id":"1f4cb9f4-99f7-4b73-877c-a1fd4b0b616c"},{"timestamp":1726704000000,"headline":"Maintainable Software (Or, where the code matters)","content":"&lt;p&gt;&lt;em&gt;Note: This post is half-baked. I wanted to put together a robust article about all the aspects of maintainable code... but instead just spat out some thoughts, got bored of the topic, and decided to leave it at that. Sorry. Hopefully it still has some meaning even in this state.&lt;/em&gt;&lt;br/&gt;&lt;br/&gt;The job of an engineer is not to write code. It is to create sustainable software. This includes:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;Yes, writing code.&lt;/li&gt;&lt;li&gt;Making sure that code is easy to follow for people who come after.&lt;/li&gt;&lt;li&gt;Documenting how the systems work together, so others can keep it running and build and scale a technical architecture.&lt;/li&gt;&lt;li&gt;Communicating with nearby teams.&lt;/li&gt;&lt;li&gt;Understanding the directions and needs of the larger business.&lt;/li&gt;&lt;li&gt;Keeping their skills up to date, in order to understand when the product needs to evolve based on changes in tech.&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;br/&gt;This post focuses on the code, but I recommend keeping a holistic view of what an engineer does because all the other aspects of their job should inform the decisions they make as they write that code.&lt;br/&gt;&lt;br/&gt;So what is maintainable code? It is code that can be changed for a reasonable level of effort, with a reasonable level of risk.&lt;br/&gt;&lt;br/&gt;Sometimes, hopefully most of the time, those changes are enhancements and updates to the software to make it work better for the organization. But when we talk about how maintainable software is, we also have to deal with the reality that most people are worried about bugs. &lt;br/&gt;&lt;br/&gt;Different coders and teams will produce different quantities of bugs. Finding and fixing those bugs is part of the job. To be clear - all code has bugs. All coders write bugs. Coders vary in how many bugs they write and how fast they deliver new features. You could plot coders on a graph with two axes: speed of code, quantity of bugs. You&amp;#x27;d end up with 4 categories of coders:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;strong&gt;Fast Coder, Many bugs&lt;/strong&gt; - Fine - the faster coding balances the bugfixing time.&lt;/li&gt;&lt;li&gt;&lt;strong&gt;Slow Coder, Few Bugs &lt;/strong&gt;- Fine - the slower delivery is balanced by less bugfixing time.&lt;/li&gt;&lt;li&gt;&lt;strong&gt;Slow Coder, Many Bugs&lt;/strong&gt; - Not OK. These are the people who are not performing well enough. &lt;/li&gt;&lt;li&gt;&lt;strong&gt;Fast Coder, Few Bugs&lt;/strong&gt; - Great - this is rare, but the ideal. &lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;br/&gt;There are specific technical approaches to coding that can reduce bugs - type-safe coding practices, re-use of common functions, automated testing and reasonable test coverage. &lt;br/&gt;&lt;br/&gt;Other thoughts, not organized... &lt;/p&gt;&lt;ul&gt;&lt;li&gt;Code should be readable - someone new to a section of code should be able to follow it. They should be able to determine how any given piece of code is run, what it does, what inputs it receives, and its output.&lt;/li&gt;&lt;li&gt;It should not be overly clever - it should use simple syntax and algorithms, and be composed into well-named functions that allow the code to tell is own story of why it exists and what it does. But don’t go overboard on that philosophy...&lt;/li&gt;&lt;li&gt;Some coders never comment their code because they feel that well-written code doesn’t need comments. That is incorrect - well-written code should not need comment to explain what it does, but it absolutely needs comments to explain why it does it, and what product and business needs led to writing the code in the first place.&lt;/li&gt;&lt;li&gt;Some of the easiest codebases I’ve worked in had a few small comments throughout any given code file, but entire books written at the top explaining the larger context of where the code in that file fits into the bigger picture and when and why it was written in the first place. This documentation helps future team members understand and update the code, and is a direct contributor to maintainability. It is part of a holistic approach to being an good engineer.&lt;/li&gt;&lt;/ul&gt;&lt;p&gt; &lt;/p&gt;","media":null,"id":"f1eac3f0-3afb-48da-9ed4-90f43331db9f"},{"timestamp":1727827200000,"headline":"Software Sustainability","content":"&lt;p&gt;&lt;strong&gt;Sustainable software &lt;/strong&gt;is software that can continue to operate over an extended timeframe, while running under a profitable business model wherein the fees paid by the customers can fully fund the operation of the ecosystem that delivers the product.&lt;br/&gt;&lt;br/&gt;&lt;/p&gt;&lt;h2&gt;Operating a software product over an extended timeframe&lt;/h2&gt;&lt;p&gt;&lt;br/&gt;Once you get past the initial creation of the software, you have plans in place to actually run the software. This means you need to have the following in place:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;A technical foundation of servers and networking to host the software including the production environment which customers access as well and the background code, servers, and services needed for the organization to operate its internal functions.&lt;/li&gt;&lt;li&gt;A support structure to communicate with customers to understand their questions, concerns, and needs.&lt;/li&gt;&lt;li&gt;A product management practice that can understand and prioritize changes needed to the product as its market and technology changes over time.&lt;/li&gt;&lt;li&gt;An engineering practice that has the ability to operate the product, make changes to the product, and has the resilience to maintain institutional knowledge as the members of the organization change.&lt;/li&gt;&lt;li&gt;A business continuity practice that covers the ability to keep the business running in cases of emergencies, disasters, and all kind of unforeseen events.&lt;/li&gt;&lt;li&gt;A corporate structure that handles all governance, legal, financial, and regulatory needs of the market in which you operate, including compensation to members of the organization.&lt;/li&gt;&lt;li&gt;Communications channels to keep all members of the organization in alignment.&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;br/&gt;The scale and scope of those elements will vary based on the scale of the software product. In a small organization, some of those bullets points can be as simple as a member of your organization who commits to handling the function. In large organizations, there may be entire departments with formal processes and frameworks in place. The details of those functions are going to vary widely, but if you are missing any one of those bullet points, you do not have the correct organizational structure in place to operate over the long term.&lt;br/&gt;&lt;br/&gt;&lt;em&gt;Side note: This is where software consultants tend to fall down. They will often focus on a single piece of this puzzle, but not the holistic need to build a sustainable product ecosystem. They have value and serve a purpose, but they are a tool, not organizational leaders. Use them wisely.&lt;/em&gt;&lt;br/&gt;&lt;/p&gt;&lt;h2&gt;A profitable business model wherein the fees paid by the customers can fully fund the operation of the ecosystem that delivers the product.&lt;/h2&gt;&lt;p&gt;&lt;br/&gt;Most people can figure out if their organization is profitable - if you bring in more money than you spend for all of the organizational functions outlined above, you are profitable.&lt;br/&gt;&lt;br/&gt;But you need to know if your software solution can be profitable before investing the time energy and money to be fully operational. The days of “build it and they will come” are long past. Your business model must include three things:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;Inputs into the system&lt;/li&gt;&lt;li&gt;Output from the system that hold value for your customer&lt;/li&gt;&lt;li&gt;At least one specific transaction from which fees are collected from customers.&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;br/&gt;You’ll find that many software startups miss that last part. There has been a long-held belief that if you find enough people to try your software, they’ll love it and pay for it. But that is not true unless you can point to the output of the product and define a specific fee to charge in exchange for that output.&lt;br/&gt;&lt;br/&gt;In most SaaS products, those elements are easy to identity. The input is data from the customer. The output is some type of processing performed against the data, organization of the results of that processing, and visualization of those results to the customer. The value they get is that your software handles that processing so they do not have to devise their own processes. In exchange for that value, they pay you - often a monthly or yearly fees, but we also see per-transaction models as well.&lt;br/&gt;&lt;br/&gt;For entertainment - streaming services, video games, etc, those elements also exist. The inputs are the content that has been created. The output is the delivery of that content to your customers. And the fees are the money the customers pay to access the content.&lt;br/&gt;&lt;br/&gt;Social media’s elements are a bit different because the primary audience of users of the service are not the customers. They are the input. Input is the existence of an audience whom advertisers want to market to. Output is the delivery of ads to that audience. The transaction is the fees paid by advertisers to the social media platform.&lt;br/&gt;&lt;br/&gt;Whatever market and customer base you are targeting, be sure you know the input, output, and core business transaction that is your actual business. And realize the truth of the software industry:&lt;br/&gt;&lt;br/&gt;The software is not your business. It is the key tool that enables your business. The transaction you identify in your business model is your actual business.&lt;br/&gt;&lt;br/&gt;This matters because in order to make a sustainable software business, you need to understand what that business is. This will drive your decisions when it comes to marketing and sales, your market research and pricing, and your prioritization of engineering and other internal efforts.&lt;/p&gt;","media":null,"id":"457f1ca4-c164-4586-bc6a-01c73db4867a"},{"timestamp":1729555200000,"headline":"Building a positive environment for building software","content":"&lt;p&gt;Lets start with why a positive environment for building the software matters. Prior posts explain that that the core business is everything other than the software, and the software is just a tool, but that should not diminish the importance put upon building a team who loves making that tool the best it can be.&lt;br/&gt;&lt;br/&gt;A positive environment is good for all stakeholders in the software development process - members of the various product and engineering teams will enjoy their work and be satisfied making it a part of their life. The business in turn has a team they can rely on to fulfill the sustainability needs of the organization.&lt;br/&gt;&lt;br/&gt;&lt;strong&gt;So what is needed to build a positive environment?&lt;/strong&gt;&lt;br/&gt;&lt;br/&gt;In short, you need to build a working environment that matches the personality of your team. In the software world, the teams tend to be comprised of members who are above average in intelligence, have a desire to be engaged with their work, and have a desire to create something new as a result of their work. They tend to want autonomy in their day-to-day work, to be trusted, and to be given a level of responsibility that matches their skills, as well as opportunity to grow their level of skills and be rewarded with increased responsibility, autonomy, and trust.&lt;br/&gt;&lt;br/&gt;This is not the same as non-software environments. There are styles of leadership that work in other industries that will fail in software. Autocratic leadership is the one style that will fail almost 100% of the time. Servant leadership works for first line managers. Higher levels of management need to be focused on delegation, direction, and alignment.&lt;br/&gt;&lt;br/&gt;My focus is on the product-focused areas of an organization. This includes:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;Engineers whose responsibility encompasses the coding and architecture of the product itself&lt;/li&gt;&lt;li&gt;Operational staff who keep the systems up and running&lt;/li&gt;&lt;li&gt;Support staff who communicate with the customers&lt;/li&gt;&lt;li&gt;Product management staff who research the market and decide what the product needs to do&lt;/li&gt;&lt;li&gt;Design staff responsibilie for how the customers and other stakeholder interact with the product.&lt;/li&gt;&lt;li&gt;QA staff who test the product and identify problems before changes are sent to the customers.&lt;/li&gt;&lt;li&gt;Leadership who keeps all those people in alignment.&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;br/&gt;Note the exclusions from this list:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;Executive leadership&lt;/li&gt;&lt;li&gt;Sales and Marketing&lt;/li&gt;&lt;li&gt;HR, accounting, and other internal corporate functions&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;br/&gt;I call out those exclusions because their satisfaction with their work environment is often not correlated with the satisfaction of the product team. I’ve seen happy product teams build amazing successful products even when other areas of the organization are miserable. Likewise, I’ve seen products fail when everyone else is happy, but the product team is miserable.&lt;br/&gt;&lt;br/&gt;&lt;strong&gt;So do you keep those teams happy?&lt;/strong&gt;&lt;br/&gt;&lt;br/&gt;This is no single answer to this. As much as there will be similarities between people who gravitate to software work, we are all different people. The number one priority when determining how to structure your product team and all its processes, communications, and other aspects of its culture is simply to listen. Ask the team how they want to work. Let them work how they want. Let them experiment and self-govern to find their best working environments. Remove people from the team who are blockers to improving the health of the team. Hire people into the team who will fit the team culture they have built. Basically, let them work their way, not yours.&lt;br/&gt;&lt;br/&gt;Even so, organizational leaders can put guardrails and requirements on the team. You can define what information you need to hear back from the team in order to understand their progress. You can give them the high-level goals that need to be accomplished. You can express the needs of the business to them. But it should be your goal to give them such requirements at as high of a level as possible, then trust them to handle the details. Your customers don’t care how the sausage is made, and really… neither should you.&lt;br/&gt;&lt;br/&gt;At least, in theory. In reality, you do need to know where the team landed on their own organization. Ideally, a senior leader lets the team make decisions that align with the needs that have been communicated, then simply confirm their direction. But sometimes you need to referee. Sometimes business needs force specific internal processes. (Security needs, regulatory needs, etc.)&lt;br/&gt;&lt;br/&gt;All that being said, there a few universal truths about a positive software culture:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;Do not rush the team. Some teams are fast, some are not, but if you push them faster than their natural pace, the quality of the product will suffer. Trust your team to know when to take shortcuts, when to put in time, when to make up for past shortcuts.&lt;/li&gt;&lt;li&gt;Everybody has an opinion about remote work. Build a team who agrees on whether or not they want to be in-person vs. remote. Mixing the two doesn’t work. This choice will exclude specific people from being on the team. Consider that a good thing - there is enough talent in this industry to go around, so if your otherwise perfect team member doesn’t want to match the rest of the team, that is a deal-killer. Hire people who match.&lt;/li&gt;&lt;li&gt;Do not micro-manage. Software people are rarely, if ever, the type of person who wants that.&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;","media":null,"id":"d379093c-bcdc-44f9-960c-e3968f3dbd92"},{"timestamp":1730332800000,"headline":"What is “good” software?","content":"&lt;p&gt;Good software does the following:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;Solves a problem - this can include any problem in business or your life, including recreational activities.&lt;/li&gt;&lt;li&gt;Is sustainable - It continues to work over time. The economics of creating and maintaining it are in balance with the fees charged for the software.&lt;/li&gt;&lt;li&gt;Is maintainable - It can be reasonably changed in order to adapt to changes in its ecosystems.&lt;/li&gt;&lt;li&gt;Is supported - The customers of the software can find the help they need when using it.&lt;/li&gt;&lt;li&gt;Is enjoyable - There needs to be an positive experience not only for the people who use it, but for the people who build, maintain, and support it.&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;br/&gt;You will note that my list of criteria for good software says nothing about the quality of the code or other technology used to build it. That is a deliberate omission. Good engineering does matter - it supports the points above. I exclude it as its own criteria to force the perspective that software engineering is a tool we use to build software, but is not a goal for its own sake.&lt;br/&gt;&lt;br/&gt;Because this can be a contentious point, I want to use the tried-and-true analogy of comparing software dev to a house. Buying a house, in this case. If you saw a house that you loved and wanted to live in, but needed repairs, you would buy the house and fix the problems. But if you saw a house in perfect condition that you did not want to live in, you would not buy that hosue no matter how perfect its craftsmanship may be.&lt;br/&gt;&lt;br/&gt;Software is the same - the craftsmanship does matter. But it is a secondary factor, not the primary goal. It makes it a sustainable place to enjoy spending time, only when and if everything already matches your needs.&lt;br/&gt;&lt;br/&gt;Another deliberate exclusion from that list is AI. For similar reasons, but with how new AI is at the time I write this, I want to comment on where it fits in good software: Anywhere. AI is a tool, just like code. If you can solve a problem with AI, do so. But do it because it is the right tool for the job. Don&amp;#x27;t add AI just because it is the latest innovation. That innovation must improve one of the points in the list above. The creation of software is about the result of all the combined elements, not the usage of any specific tool. &lt;/p&gt;","media":null,"id":"9e436548-4d13-43c2-a40f-bc8e82ac15e4"}];
const isDev = false;
const page = "softwaredev";
const title = "Software Development";
const description = "Thoughts on the software industry";
const sortedDates = [{"timestamp":"2024-10-18","headline":"Finding a problem to solve","content":"&lt;p&gt;Software does not hold value in and of itself. This may be an unpleasant truth for those who like to write code, but software needs to add value to the lives of people to use it for it to become a successful software product. There is nothing wrong with hobby projects either, but even if you are the only user, it still need to add value for you.&lt;br/&gt;&lt;br/&gt;Making sure your product solves a problem is the key starting point for a software product. And also where people often get stuck.&lt;br/&gt;&lt;br/&gt;The most successful software products I’ve seen almost start themselves - there is a problem causing enough pain that people seek out a solution, talk to people who can make software, and they work together to solve the problem.&lt;br/&gt;&lt;br/&gt;But those people probably aren’t reading this - you are probably seeking the opposite origin story for your product, that you want to build and operate a software business, but need to go find that idea.&lt;br/&gt;&lt;br/&gt;The best way to make that work is to force the situation where you fix a pain point. Go out and talk to people who work in industries that interest you. Ask them where they feel frustration in their days, and which of those problems causes financial burdens to their company. Then see if you can envision a software product that resolves it.&lt;br/&gt;Be careful to actually be solving the problem with software, and not masking a process re-engineering effort by putting software over top of it. Many problems in business are due to poor processes or communication, and software can solve those. But you need to ask yourself if the same process or communications improvements can be done without software. If they can, your product is just a shiny layer on top of the actual fix, and some day in the future someone can easily get rid of your product.&lt;br/&gt;&lt;br/&gt;&lt;em&gt;Side Note: Entertainment is a valid problem to solve. Video games are software, as are streaming services, chat apps, and other apps that don’t solve business problems but do make people more satisfied with their lives.&lt;/em&gt;&lt;br/&gt;&lt;br/&gt;Software adds value when it does things people are not great at - collecting data, visualizing data, synthesizing data. Automating processes and tasks, organizing incoming requests.&lt;br/&gt;&lt;br/&gt;One way to make sure your software has intrinsic value is to make sure you can specify its inputs and outputs, and that your customers are willing to pay a fee for the process of turning those inputs into those outputs. If you cannot abstract what your software does into an input, output and a financial transaction in exchange for that conversion, you might not have a viable software product.&lt;br/&gt;&lt;br/&gt;Another path is to find a product that has already solved a problem, but done it poorly. Find software that is critical to an industry, but disliked because it is not good software. Then simply do a better job than they did.&lt;br/&gt;&lt;br/&gt;Don’t discount your own problems, either. Write software for just yourself, if it makes your own life better. Then ask around and see if anyone else has the same problem and might want to try your solution.&lt;br/&gt; &lt;br/&gt; &lt;br/&gt; &lt;br/&gt; &lt;/p&gt;","media":null,"id":"1f4cb9f4-99f7-4b73-877c-a1fd4b0b616c"},{"timestamp":1726704000000,"headline":"Maintainable Software (Or, where the code matters)","content":"&lt;p&gt;&lt;em&gt;Note: This post is half-baked. I wanted to put together a robust article about all the aspects of maintainable code... but instead just spat out some thoughts, got bored of the topic, and decided to leave it at that. Sorry. Hopefully it still has some meaning even in this state.&lt;/em&gt;&lt;br/&gt;&lt;br/&gt;The job of an engineer is not to write code. It is to create sustainable software. This includes:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;Yes, writing code.&lt;/li&gt;&lt;li&gt;Making sure that code is easy to follow for people who come after.&lt;/li&gt;&lt;li&gt;Documenting how the systems work together, so others can keep it running and build and scale a technical architecture.&lt;/li&gt;&lt;li&gt;Communicating with nearby teams.&lt;/li&gt;&lt;li&gt;Understanding the directions and needs of the larger business.&lt;/li&gt;&lt;li&gt;Keeping their skills up to date, in order to understand when the product needs to evolve based on changes in tech.&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;br/&gt;This post focuses on the code, but I recommend keeping a holistic view of what an engineer does because all the other aspects of their job should inform the decisions they make as they write that code.&lt;br/&gt;&lt;br/&gt;So what is maintainable code? It is code that can be changed for a reasonable level of effort, with a reasonable level of risk.&lt;br/&gt;&lt;br/&gt;Sometimes, hopefully most of the time, those changes are enhancements and updates to the software to make it work better for the organization. But when we talk about how maintainable software is, we also have to deal with the reality that most people are worried about bugs. &lt;br/&gt;&lt;br/&gt;Different coders and teams will produce different quantities of bugs. Finding and fixing those bugs is part of the job. To be clear - all code has bugs. All coders write bugs. Coders vary in how many bugs they write and how fast they deliver new features. You could plot coders on a graph with two axes: speed of code, quantity of bugs. You&amp;#x27;d end up with 4 categories of coders:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;strong&gt;Fast Coder, Many bugs&lt;/strong&gt; - Fine - the faster coding balances the bugfixing time.&lt;/li&gt;&lt;li&gt;&lt;strong&gt;Slow Coder, Few Bugs &lt;/strong&gt;- Fine - the slower delivery is balanced by less bugfixing time.&lt;/li&gt;&lt;li&gt;&lt;strong&gt;Slow Coder, Many Bugs&lt;/strong&gt; - Not OK. These are the people who are not performing well enough. &lt;/li&gt;&lt;li&gt;&lt;strong&gt;Fast Coder, Few Bugs&lt;/strong&gt; - Great - this is rare, but the ideal. &lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;br/&gt;There are specific technical approaches to coding that can reduce bugs - type-safe coding practices, re-use of common functions, automated testing and reasonable test coverage. &lt;br/&gt;&lt;br/&gt;Other thoughts, not organized... &lt;/p&gt;&lt;ul&gt;&lt;li&gt;Code should be readable - someone new to a section of code should be able to follow it. They should be able to determine how any given piece of code is run, what it does, what inputs it receives, and its output.&lt;/li&gt;&lt;li&gt;It should not be overly clever - it should use simple syntax and algorithms, and be composed into well-named functions that allow the code to tell is own story of why it exists and what it does. But don’t go overboard on that philosophy...&lt;/li&gt;&lt;li&gt;Some coders never comment their code because they feel that well-written code doesn’t need comments. That is incorrect - well-written code should not need comment to explain what it does, but it absolutely needs comments to explain why it does it, and what product and business needs led to writing the code in the first place.&lt;/li&gt;&lt;li&gt;Some of the easiest codebases I’ve worked in had a few small comments throughout any given code file, but entire books written at the top explaining the larger context of where the code in that file fits into the bigger picture and when and why it was written in the first place. This documentation helps future team members understand and update the code, and is a direct contributor to maintainability. It is part of a holistic approach to being an good engineer.&lt;/li&gt;&lt;/ul&gt;&lt;p&gt; &lt;/p&gt;","media":null,"id":"f1eac3f0-3afb-48da-9ed4-90f43331db9f"},{"timestamp":1727827200000,"headline":"Software Sustainability","content":"&lt;p&gt;&lt;strong&gt;Sustainable software &lt;/strong&gt;is software that can continue to operate over an extended timeframe, while running under a profitable business model wherein the fees paid by the customers can fully fund the operation of the ecosystem that delivers the product.&lt;br/&gt;&lt;br/&gt;&lt;/p&gt;&lt;h2&gt;Operating a software product over an extended timeframe&lt;/h2&gt;&lt;p&gt;&lt;br/&gt;Once you get past the initial creation of the software, you have plans in place to actually run the software. This means you need to have the following in place:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;A technical foundation of servers and networking to host the software including the production environment which customers access as well and the background code, servers, and services needed for the organization to operate its internal functions.&lt;/li&gt;&lt;li&gt;A support structure to communicate with customers to understand their questions, concerns, and needs.&lt;/li&gt;&lt;li&gt;A product management practice that can understand and prioritize changes needed to the product as its market and technology changes over time.&lt;/li&gt;&lt;li&gt;An engineering practice that has the ability to operate the product, make changes to the product, and has the resilience to maintain institutional knowledge as the members of the organization change.&lt;/li&gt;&lt;li&gt;A business continuity practice that covers the ability to keep the business running in cases of emergencies, disasters, and all kind of unforeseen events.&lt;/li&gt;&lt;li&gt;A corporate structure that handles all governance, legal, financial, and regulatory needs of the market in which you operate, including compensation to members of the organization.&lt;/li&gt;&lt;li&gt;Communications channels to keep all members of the organization in alignment.&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;br/&gt;The scale and scope of those elements will vary based on the scale of the software product. In a small organization, some of those bullets points can be as simple as a member of your organization who commits to handling the function. In large organizations, there may be entire departments with formal processes and frameworks in place. The details of those functions are going to vary widely, but if you are missing any one of those bullet points, you do not have the correct organizational structure in place to operate over the long term.&lt;br/&gt;&lt;br/&gt;&lt;em&gt;Side note: This is where software consultants tend to fall down. They will often focus on a single piece of this puzzle, but not the holistic need to build a sustainable product ecosystem. They have value and serve a purpose, but they are a tool, not organizational leaders. Use them wisely.&lt;/em&gt;&lt;br/&gt;&lt;/p&gt;&lt;h2&gt;A profitable business model wherein the fees paid by the customers can fully fund the operation of the ecosystem that delivers the product.&lt;/h2&gt;&lt;p&gt;&lt;br/&gt;Most people can figure out if their organization is profitable - if you bring in more money than you spend for all of the organizational functions outlined above, you are profitable.&lt;br/&gt;&lt;br/&gt;But you need to know if your software solution can be profitable before investing the time energy and money to be fully operational. The days of “build it and they will come” are long past. Your business model must include three things:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;Inputs into the system&lt;/li&gt;&lt;li&gt;Output from the system that hold value for your customer&lt;/li&gt;&lt;li&gt;At least one specific transaction from which fees are collected from customers.&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;br/&gt;You’ll find that many software startups miss that last part. There has been a long-held belief that if you find enough people to try your software, they’ll love it and pay for it. But that is not true unless you can point to the output of the product and define a specific fee to charge in exchange for that output.&lt;br/&gt;&lt;br/&gt;In most SaaS products, those elements are easy to identity. The input is data from the customer. The output is some type of processing performed against the data, organization of the results of that processing, and visualization of those results to the customer. The value they get is that your software handles that processing so they do not have to devise their own processes. In exchange for that value, they pay you - often a monthly or yearly fees, but we also see per-transaction models as well.&lt;br/&gt;&lt;br/&gt;For entertainment - streaming services, video games, etc, those elements also exist. The inputs are the content that has been created. The output is the delivery of that content to your customers. And the fees are the money the customers pay to access the content.&lt;br/&gt;&lt;br/&gt;Social media’s elements are a bit different because the primary audience of users of the service are not the customers. They are the input. Input is the existence of an audience whom advertisers want to market to. Output is the delivery of ads to that audience. The transaction is the fees paid by advertisers to the social media platform.&lt;br/&gt;&lt;br/&gt;Whatever market and customer base you are targeting, be sure you know the input, output, and core business transaction that is your actual business. And realize the truth of the software industry:&lt;br/&gt;&lt;br/&gt;The software is not your business. It is the key tool that enables your business. The transaction you identify in your business model is your actual business.&lt;br/&gt;&lt;br/&gt;This matters because in order to make a sustainable software business, you need to understand what that business is. This will drive your decisions when it comes to marketing and sales, your market research and pricing, and your prioritization of engineering and other internal efforts.&lt;/p&gt;","media":null,"id":"457f1ca4-c164-4586-bc6a-01c73db4867a"},{"timestamp":1729555200000,"headline":"Building a positive environment for building software","content":"&lt;p&gt;Lets start with why a positive environment for building the software matters. Prior posts explain that that the core business is everything other than the software, and the software is just a tool, but that should not diminish the importance put upon building a team who loves making that tool the best it can be.&lt;br/&gt;&lt;br/&gt;A positive environment is good for all stakeholders in the software development process - members of the various product and engineering teams will enjoy their work and be satisfied making it a part of their life. The business in turn has a team they can rely on to fulfill the sustainability needs of the organization.&lt;br/&gt;&lt;br/&gt;&lt;strong&gt;So what is needed to build a positive environment?&lt;/strong&gt;&lt;br/&gt;&lt;br/&gt;In short, you need to build a working environment that matches the personality of your team. In the software world, the teams tend to be comprised of members who are above average in intelligence, have a desire to be engaged with their work, and have a desire to create something new as a result of their work. They tend to want autonomy in their day-to-day work, to be trusted, and to be given a level of responsibility that matches their skills, as well as opportunity to grow their level of skills and be rewarded with increased responsibility, autonomy, and trust.&lt;br/&gt;&lt;br/&gt;This is not the same as non-software environments. There are styles of leadership that work in other industries that will fail in software. Autocratic leadership is the one style that will fail almost 100% of the time. Servant leadership works for first line managers. Higher levels of management need to be focused on delegation, direction, and alignment.&lt;br/&gt;&lt;br/&gt;My focus is on the product-focused areas of an organization. This includes:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;Engineers whose responsibility encompasses the coding and architecture of the product itself&lt;/li&gt;&lt;li&gt;Operational staff who keep the systems up and running&lt;/li&gt;&lt;li&gt;Support staff who communicate with the customers&lt;/li&gt;&lt;li&gt;Product management staff who research the market and decide what the product needs to do&lt;/li&gt;&lt;li&gt;Design staff responsibilie for how the customers and other stakeholder interact with the product.&lt;/li&gt;&lt;li&gt;QA staff who test the product and identify problems before changes are sent to the customers.&lt;/li&gt;&lt;li&gt;Leadership who keeps all those people in alignment.&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;br/&gt;Note the exclusions from this list:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;Executive leadership&lt;/li&gt;&lt;li&gt;Sales and Marketing&lt;/li&gt;&lt;li&gt;HR, accounting, and other internal corporate functions&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;br/&gt;I call out those exclusions because their satisfaction with their work environment is often not correlated with the satisfaction of the product team. I’ve seen happy product teams build amazing successful products even when other areas of the organization are miserable. Likewise, I’ve seen products fail when everyone else is happy, but the product team is miserable.&lt;br/&gt;&lt;br/&gt;&lt;strong&gt;So do you keep those teams happy?&lt;/strong&gt;&lt;br/&gt;&lt;br/&gt;This is no single answer to this. As much as there will be similarities between people who gravitate to software work, we are all different people. The number one priority when determining how to structure your product team and all its processes, communications, and other aspects of its culture is simply to listen. Ask the team how they want to work. Let them work how they want. Let them experiment and self-govern to find their best working environments. Remove people from the team who are blockers to improving the health of the team. Hire people into the team who will fit the team culture they have built. Basically, let them work their way, not yours.&lt;br/&gt;&lt;br/&gt;Even so, organizational leaders can put guardrails and requirements on the team. You can define what information you need to hear back from the team in order to understand their progress. You can give them the high-level goals that need to be accomplished. You can express the needs of the business to them. But it should be your goal to give them such requirements at as high of a level as possible, then trust them to handle the details. Your customers don’t care how the sausage is made, and really… neither should you.&lt;br/&gt;&lt;br/&gt;At least, in theory. In reality, you do need to know where the team landed on their own organization. Ideally, a senior leader lets the team make decisions that align with the needs that have been communicated, then simply confirm their direction. But sometimes you need to referee. Sometimes business needs force specific internal processes. (Security needs, regulatory needs, etc.)&lt;br/&gt;&lt;br/&gt;All that being said, there a few universal truths about a positive software culture:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;Do not rush the team. Some teams are fast, some are not, but if you push them faster than their natural pace, the quality of the product will suffer. Trust your team to know when to take shortcuts, when to put in time, when to make up for past shortcuts.&lt;/li&gt;&lt;li&gt;Everybody has an opinion about remote work. Build a team who agrees on whether or not they want to be in-person vs. remote. Mixing the two doesn’t work. This choice will exclude specific people from being on the team. Consider that a good thing - there is enough talent in this industry to go around, so if your otherwise perfect team member doesn’t want to match the rest of the team, that is a deal-killer. Hire people who match.&lt;/li&gt;&lt;li&gt;Do not micro-manage. Software people are rarely, if ever, the type of person who wants that.&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;","media":null,"id":"d379093c-bcdc-44f9-960c-e3968f3dbd92"},{"timestamp":1730332800000,"headline":"What is “good” software?","content":"&lt;p&gt;Good software does the following:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;Solves a problem - this can include any problem in business or your life, including recreational activities.&lt;/li&gt;&lt;li&gt;Is sustainable - It continues to work over time. The economics of creating and maintaining it are in balance with the fees charged for the software.&lt;/li&gt;&lt;li&gt;Is maintainable - It can be reasonably changed in order to adapt to changes in its ecosystems.&lt;/li&gt;&lt;li&gt;Is supported - The customers of the software can find the help they need when using it.&lt;/li&gt;&lt;li&gt;Is enjoyable - There needs to be an positive experience not only for the people who use it, but for the people who build, maintain, and support it.&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;br/&gt;You will note that my list of criteria for good software says nothing about the quality of the code or other technology used to build it. That is a deliberate omission. Good engineering does matter - it supports the points above. I exclude it as its own criteria to force the perspective that software engineering is a tool we use to build software, but is not a goal for its own sake.&lt;br/&gt;&lt;br/&gt;Because this can be a contentious point, I want to use the tried-and-true analogy of comparing software dev to a house. Buying a house, in this case. If you saw a house that you loved and wanted to live in, but needed repairs, you would buy the house and fix the problems. But if you saw a house in perfect condition that you did not want to live in, you would not buy that hosue no matter how perfect its craftsmanship may be.&lt;br/&gt;&lt;br/&gt;Software is the same - the craftsmanship does matter. But it is a secondary factor, not the primary goal. It makes it a sustainable place to enjoy spending time, only when and if everything already matches your needs.&lt;br/&gt;&lt;br/&gt;Another deliberate exclusion from that list is AI. For similar reasons, but with how new AI is at the time I write this, I want to comment on where it fits in good software: Anywhere. AI is a tool, just like code. If you can solve a problem with AI, do so. But do it because it is the right tool for the job. Don&amp;#x27;t add AI just because it is the latest innovation. That innovation must improve one of the points in the list above. The creation of software is about the result of all the combined elements, not the usage of any specific tool. &lt;/p&gt;","media":null,"id":"9e436548-4d13-43c2-a40f-bc8e82ac15e4"}];

  let quill = null;
  let dateId = 0;
  let isDirty = false;

  async function saveContent(fieldName, fieldValue) {
    const filePath = `/src/data/content/${page}`;

    if (fieldName === "content") {
      fieldValue = encodeHtmlForJson(fieldValue);
    }

    try {
      const response = await fetch("/api/saveDateField", {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
        },
        body: JSON.stringify({
          filePath,
          fieldName,
          fieldValue,
          id: dateId,
        }),
      });

      if (!response.ok) {
        throw new Error(`HTTP error! Status: ${response.status}`);
      }
    } catch (error) {
      console.error("Error saving page contents:", error);
    }
  }

  function layoutItems() {
    let leftBottom = 0;
    let rightBottom = 0;

    const timelineItems = document.querySelectorAll(".timeline-item");

    for (let i = 0; i < timelineItems.length; i++) {
      const current = timelineItems[i];
      const content = current.querySelector(".content");
     
      if (window.innerWidth < 786) {
        current.classList.remove("left");
        current.classList.remove("right");
        current.classList.add("full");
        current.style.top = `${leftBottom}px`;
        leftBottom += content.offsetHeight + 10;
      } else if (leftBottom <= rightBottom) {
        current.classList.remove("full");
        current.classList.remove("right");
        current.classList.add("left");
        current.style.top = `${leftBottom}px`;
        leftBottom += content.offsetHeight + 10;
      } else {
        current.classList.remove("full");
        current.classList.remove("left");
        current.classList.add("right");
        current.style.top = `${rightBottom}px`;
        rightBottom += content.offsetHeight + 10;
      }
    }
  }

  async function saveDateField(fieldName, fieldValue, dateId) {
    const filePath = `/src/data/content/${page}`;

    if (fieldName === "content") {
      fieldValue = encodeHtmlForJson(fieldValue);
    }
    try {
      const response = await fetch("/api/saveDateField", {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
        },
        body: JSON.stringify({
          filePath,
          fieldName,
          fieldValue,
          id: dateId,
        }),
      });

      if (!response.ok) {
        throw new Error(`HTTP error! Status: ${response.status}`);
      }
     
    } catch (error) {
      console.error("Error saving page contents:", error);
    }
  }

  async function deleteDate(dateId) {
    if (!confirm("Delete this Date?")) return;

    const filePath = `/src/data/content/${page}`;
    const date = sortedDates.find(date => date.id === dateId);
    try {
      const response = await fetch("/api/deleteDate", {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
        },
        body: JSON.stringify({ filePath, date }),
      });

      if (!response.ok) {
        throw new Error(`HTTP error! Status: ${response.status}`);
      }
    } catch (error) {
      console.error("Error saving page contents:", error);
    }
  }

  function setupEditor() {
    const toolbarOptions = [
      ["bold", "italic", "underline", "strike"],
      ["blockquote", "code-block"],
      [{ header: 1 }, { header: 2 }],
      [{ list: "ordered" }, { list: "bullet" }],
      [{ script: "sub" }, { script: "super" }],
      [{ indent: "-1" }, { indent: "+1" }],
      [{ direction: "rtl" }],
      [{ size: ["small", false, "large", "huge"] }],
      [{ header: [1, 2, 3, 4, 5, 6, false] }],
      [{ color: [] }, { background: [] }],
      [{ font: [] }],
      [{ align: [] }],
      ["clean"],
      ["link", "image", "video"],
    ];
    // Initialize Quill
    quill = new Quill("#editor", {
      modules: {
        toolbar: toolbarOptions,
      },
      theme: "snow",
    });
    quill.on("text-change", () => {
      isDirty = true;
    });

    const dateElements = document.querySelectorAll(".timeline-item");
    const editForm = document.querySelector(".edit-form");
    const dateField = document.getElementById("dateField");
    const headlineField = document.getElementById("headlineField");

    dateElements.forEach((dateElement) => {
      const index = dateElement.getAttribute("data-index");
      const id = dateElement.getAttribute("data-id");

      dateElement
        .querySelector(`#edit-${index}`)
        .addEventListener("click", () => {
          quill.root.innerHTML =
            dateElement.querySelector(".content").innerHTML;
          isDirty = false;
          dateId = id;
          dateField.value = new Date(sortedDates.find(date => date.id === dateId).timestamp)
            .toISOString()
            .split(":")
            .slice(0, -1)
            .join(":");
          headlineField.value = sortedDates[index].headline;
          editForm.style.visibility = "visible";
        });
    });

    const closeButton = document.getElementById("close-edit-form");
    closeButton.addEventListener("click", () => {
      if (isDirty) {
        if (
          !confirm(
            "You have unsaved changes. Are you sure you want to continue?"
          )
        ) {
          return;
        }
      }
      editForm.style.visibility = "hidden";
    });

    const saveButton = document.querySelector("#save-button");
    saveButton.addEventListener("click", () => {
      saveContent("content", quill.root.innerHTML);
    });

    const deleteButton = document.getElementById("deleteDate");
    deleteButton.addEventListener("click", (e) => {
      e.preventDefault();
      deleteDate(dateId);
    });

    const saveDateButton = document.getElementById("saveDate");
    saveDateButton.addEventListener("click", (e) => {
      e.preventDefault();
      saveDateField("timestamp", new Date(dateField.value).getTime(), dateId);
      editForm.style.visibility = "hidden";
    });

    const saveHeadlineButton = document.getElementById("saveHeadline");
    saveHeadlineButton.addEventListener("click", (e) => {
      e.preventDefault();
      saveDateField("headline", headlineField.value, dateId);
      editForm.style.visibility = "hidden";
    });
  }

  document.addEventListener("DOMContentLoaded", () => {
    layoutItems();
    window.addEventListener("resize", layoutItems);
    // if anyone see this on the public site...
    // Hi! Yes, you could just change isDev to true in your browser.
    // This will not give you access to change anything. This all was exported to static HTML.
    // It will just make it easier for you to break your UI and get 404s as there is no back-end server when deployed.
    if (isDev) setupEditor();
  });
})();</script> <script astro:false defer="defer" src="https://us.umami.is/script.js" data-website-id="02a4968a-0e7b-4694-b330-8e0afe204556"></script><script>
  function encodeHtmlEntities(str) {
    return str
      .replace(/&/g, "&")
      .replace(/</g, "<")
      .replace(/>/g, ">")
      .replace(/"/g, '"')
      .replace(/'/g, "'");
  }

  function encodeHtmlForJson(html) {
    return JSON.stringify(encodeHtmlEntities(html)).slice(1, -1);
  }
</script><meta charset="UTF-8"><meta name="viewport" content="width=device-width"><link rel="icon" type="image/svg+xml" href="/favicon.svg"><meta name="generator" content="Astro v5.1.3"><title>Topics</title> <style>html,body{font-family:Helvetica Neue,Arial,sans-serif;margin:0 auto;padding:0;display:flex;flex-direction:column}h1{font-family:Georgia;font-size:1.8em;text-align:center;margin-top:20px;margin-bottom:10px}h2{font-family:Georgia;font-size:1.3em;margin-top:10px;text-align:center}p{font-size:1.1em;line-height:1.2;margin:10px}a{text-decoration:none;transition:color .3s}a:hover{text-decoration:underline}.contact{text-align:right;font-size:.9em;color:#133059;padding:10px 25px 10px 0;margin-top:0;flex-shrink:0}strong{font-weight:700}.svg-black{fill:none;stroke:#000;stroke-width:2;stroke-linecap:round;stroke-linejoin:round;stroke-miterlimit:10}.svg-white{fill:none;stroke:#eee;stroke-width:2;stroke-linecap:round;stroke-linejoin:round;stroke-miterlimit:10}.bg-dark{background:#194062}.bg-medium{background:#6a88a9}.bg-light{background:#bbd0e3}.font-light{color:#cfe5f8}.font-dark{color:#222}
body{margin:0;padding:0;font-family:Arial,sans-serif}header{padding:10px 20px}a{text-decoration:underline}.description{font-size:1.1rem;text-align:center;display:block}button{margin:.5rem;padding:.25rem .5rem;border-radius:.25rem;font-size:.8rem;background-color:#2d3748;color:#fff;border:none;cursor:pointer}button:hover{background-color:#2980b9}.ql-toolbar{border-radius:6px}.timeline{position:relative;max-width:1400px;margin:0 auto;padding:20px;height:auto}.timeline-item{position:relative;margin:10px 0 0;padding-top:10px}.date-title{position:relative;left:50%;line-height:20px;width:calc(50% - 38px);z-index:2;padding:0;border-radius:8px 8px 0 0}.date-title-inner{padding:8px 16px;position:relative;display:flex;gap:16px}.left .date-title-inner{flex-direction:row-reverse}.timeline-item.right .date-title{transform:translate(9px);text-align:right;margin-left:20px}.timeline-item.left .date-title{transform:translate(calc(-100% - 29px));text-align:right}.timeline-item.left .content{right:calc(50% + 30px)}.timeline-item.right .content{left:calc(50% + 30px)}.timeline-item.full .content{border-radius:10px}.content{position:absolute;width:calc(50% - 80px);padding:30px 20px;border-radius:0 0 10px 10px;box-shadow:0 2px 5px #0000001a}.full .content{width:90%}.timeline-item{margin-top:2px}.date-title h3{margin:0;font-size:1em}.date-title div{font-size:.9em}.timeline-item svg{cursor:pointer}.edit-form{visibility:hidden;position:fixed;top:5%;left:100px;width:85%;height:800px;border:2px solid #000;border-radius:10px;margin:0 auto;padding:30px;z-index:1000}#close-edit-form{position:relative;text-align:right;left:35px;width:100%;top:-40px;cursor:pointer}#editor{height:600px;background:#fff}
</style><body class="bg-medium font-dark"> <div class="contact bg-medium font-dark">
Contact: hikingdave @ gmail.com || <a class="font-dark" href="https://codingdave.com">codingdave.com</a> </div>  <script astro:false src="https://cdn.jsdelivr.net/npm/quill@2.0.3/dist/quill.js"></script> <link href="https://cdn.jsdelivr.net/npm/quill@2.0.3/dist/quill.snow.css" rel="stylesheet"> <div class="page"> <header class="bg-light"> <span><a class="font-dark" href="../">Back to Topic List</a></span> <h1>Software Development</h1> <span class="description font-dark"><strong>Thoughts on the software industry</strong></span>  </header> <div class="timeline bg-medium"> <div class="timeline-item" data-index="0" data-id="1f4cb9f4-99f7-4b73-877c-a1fd4b0b616c"> <div class="date-title bg-dark font-light"> <div class="date-title-inner"> <div>10/17/2024</div> <div><strong>Finding a problem to solve</strong></div>  </div> </div> <div class="content bg-light"><p>Software does not hold value in and of itself. This may be an unpleasant truth for those who like to write code, but software needs to add value to the lives of people to use it for it to become a successful software product. There is nothing wrong with hobby projects either, but even if you are the only user, it still need to add value for you.<br/><br/>Making sure your product solves a problem is the key starting point for a software product. And also where people often get stuck.<br/><br/>The most successful software products I’ve seen almost start themselves - there is a problem causing enough pain that people seek out a solution, talk to people who can make software, and they work together to solve the problem.<br/><br/>But those people probably aren’t reading this - you are probably seeking the opposite origin story for your product, that you want to build and operate a software business, but need to go find that idea.<br/><br/>The best way to make that work is to force the situation where you fix a pain point. Go out and talk to people who work in industries that interest you. Ask them where they feel frustration in their days, and which of those problems causes financial burdens to their company. Then see if you can envision a software product that resolves it.<br/>Be careful to actually be solving the problem with software, and not masking a process re-engineering effort by putting software over top of it. Many problems in business are due to poor processes or communication, and software can solve those. But you need to ask yourself if the same process or communications improvements can be done without software. If they can, your product is just a shiny layer on top of the actual fix, and some day in the future someone can easily get rid of your product.<br/><br/><em>Side Note: Entertainment is a valid problem to solve. Video games are software, as are streaming services, chat apps, and other apps that don’t solve business problems but do make people more satisfied with their lives.</em><br/><br/>Software adds value when it does things people are not great at - collecting data, visualizing data, synthesizing data. Automating processes and tasks, organizing incoming requests.<br/><br/>One way to make sure your software has intrinsic value is to make sure you can specify its inputs and outputs, and that your customers are willing to pay a fee for the process of turning those inputs into those outputs. If you cannot abstract what your software does into an input, output and a financial transaction in exchange for that conversion, you might not have a viable software product.<br/><br/>Another path is to find a product that has already solved a problem, but done it poorly. Find software that is critical to an industry, but disliked because it is not good software. Then simply do a better job than they did.<br/><br/>Don’t discount your own problems, either. Write software for just yourself, if it makes your own life better. Then ask around and see if anyone else has the same problem and might want to try your solution.<br/> <br/> <br/> <br/> </p></div> </div><div class="timeline-item" data-index="1" data-id="f1eac3f0-3afb-48da-9ed4-90f43331db9f"> <div class="date-title bg-dark font-light"> <div class="date-title-inner"> <div>9/18/2024</div> <div><strong>Maintainable Software (Or, where the code matters)</strong></div>  </div> </div> <div class="content bg-light"><p><em>Note: This post is half-baked. I wanted to put together a robust article about all the aspects of maintainable code... but instead just spat out some thoughts, got bored of the topic, and decided to leave it at that. Sorry. Hopefully it still has some meaning even in this state.</em><br/><br/>The job of an engineer is not to write code. It is to create sustainable software. This includes:</p><ul><li>Yes, writing code.</li><li>Making sure that code is easy to follow for people who come after.</li><li>Documenting how the systems work together, so others can keep it running and build and scale a technical architecture.</li><li>Communicating with nearby teams.</li><li>Understanding the directions and needs of the larger business.</li><li>Keeping their skills up to date, in order to understand when the product needs to evolve based on changes in tech.</li></ul><p><br/>This post focuses on the code, but I recommend keeping a holistic view of what an engineer does because all the other aspects of their job should inform the decisions they make as they write that code.<br/><br/>So what is maintainable code? It is code that can be changed for a reasonable level of effort, with a reasonable level of risk.<br/><br/>Sometimes, hopefully most of the time, those changes are enhancements and updates to the software to make it work better for the organization. But when we talk about how maintainable software is, we also have to deal with the reality that most people are worried about bugs. <br/><br/>Different coders and teams will produce different quantities of bugs. Finding and fixing those bugs is part of the job. To be clear - all code has bugs. All coders write bugs. Coders vary in how many bugs they write and how fast they deliver new features. You could plot coders on a graph with two axes: speed of code, quantity of bugs. You&#x27;d end up with 4 categories of coders:</p><ul><li><strong>Fast Coder, Many bugs</strong> - Fine - the faster coding balances the bugfixing time.</li><li><strong>Slow Coder, Few Bugs </strong>- Fine - the slower delivery is balanced by less bugfixing time.</li><li><strong>Slow Coder, Many Bugs</strong> - Not OK. These are the people who are not performing well enough. </li><li><strong>Fast Coder, Few Bugs</strong> - Great - this is rare, but the ideal. </li></ul><p><br/>There are specific technical approaches to coding that can reduce bugs - type-safe coding practices, re-use of common functions, automated testing and reasonable test coverage. <br/><br/>Other thoughts, not organized... </p><ul><li>Code should be readable - someone new to a section of code should be able to follow it. They should be able to determine how any given piece of code is run, what it does, what inputs it receives, and its output.</li><li>It should not be overly clever - it should use simple syntax and algorithms, and be composed into well-named functions that allow the code to tell is own story of why it exists and what it does. But don’t go overboard on that philosophy...</li><li>Some coders never comment their code because they feel that well-written code doesn’t need comments. That is incorrect - well-written code should not need comment to explain what it does, but it absolutely needs comments to explain why it does it, and what product and business needs led to writing the code in the first place.</li><li>Some of the easiest codebases I’ve worked in had a few small comments throughout any given code file, but entire books written at the top explaining the larger context of where the code in that file fits into the bigger picture and when and why it was written in the first place. This documentation helps future team members understand and update the code, and is a direct contributor to maintainability. It is part of a holistic approach to being an good engineer.</li></ul><p> </p></div> </div><div class="timeline-item" data-index="2" data-id="457f1ca4-c164-4586-bc6a-01c73db4867a"> <div class="date-title bg-dark font-light"> <div class="date-title-inner"> <div>10/1/2024</div> <div><strong>Software Sustainability</strong></div>  </div> </div> <div class="content bg-light"><p><strong>Sustainable software </strong>is software that can continue to operate over an extended timeframe, while running under a profitable business model wherein the fees paid by the customers can fully fund the operation of the ecosystem that delivers the product.<br/><br/></p><h2>Operating a software product over an extended timeframe</h2><p><br/>Once you get past the initial creation of the software, you have plans in place to actually run the software. This means you need to have the following in place:</p><ul><li>A technical foundation of servers and networking to host the software including the production environment which customers access as well and the background code, servers, and services needed for the organization to operate its internal functions.</li><li>A support structure to communicate with customers to understand their questions, concerns, and needs.</li><li>A product management practice that can understand and prioritize changes needed to the product as its market and technology changes over time.</li><li>An engineering practice that has the ability to operate the product, make changes to the product, and has the resilience to maintain institutional knowledge as the members of the organization change.</li><li>A business continuity practice that covers the ability to keep the business running in cases of emergencies, disasters, and all kind of unforeseen events.</li><li>A corporate structure that handles all governance, legal, financial, and regulatory needs of the market in which you operate, including compensation to members of the organization.</li><li>Communications channels to keep all members of the organization in alignment.</li></ul><p><br/>The scale and scope of those elements will vary based on the scale of the software product. In a small organization, some of those bullets points can be as simple as a member of your organization who commits to handling the function. In large organizations, there may be entire departments with formal processes and frameworks in place. The details of those functions are going to vary widely, but if you are missing any one of those bullet points, you do not have the correct organizational structure in place to operate over the long term.<br/><br/><em>Side note: This is where software consultants tend to fall down. They will often focus on a single piece of this puzzle, but not the holistic need to build a sustainable product ecosystem. They have value and serve a purpose, but they are a tool, not organizational leaders. Use them wisely.</em><br/></p><h2>A profitable business model wherein the fees paid by the customers can fully fund the operation of the ecosystem that delivers the product.</h2><p><br/>Most people can figure out if their organization is profitable - if you bring in more money than you spend for all of the organizational functions outlined above, you are profitable.<br/><br/>But you need to know if your software solution can be profitable before investing the time energy and money to be fully operational. The days of “build it and they will come” are long past. Your business model must include three things:</p><ul><li>Inputs into the system</li><li>Output from the system that hold value for your customer</li><li>At least one specific transaction from which fees are collected from customers.</li></ul><p><br/>You’ll find that many software startups miss that last part. There has been a long-held belief that if you find enough people to try your software, they’ll love it and pay for it. But that is not true unless you can point to the output of the product and define a specific fee to charge in exchange for that output.<br/><br/>In most SaaS products, those elements are easy to identity. The input is data from the customer. The output is some type of processing performed against the data, organization of the results of that processing, and visualization of those results to the customer. The value they get is that your software handles that processing so they do not have to devise their own processes. In exchange for that value, they pay you - often a monthly or yearly fees, but we also see per-transaction models as well.<br/><br/>For entertainment - streaming services, video games, etc, those elements also exist. The inputs are the content that has been created. The output is the delivery of that content to your customers. And the fees are the money the customers pay to access the content.<br/><br/>Social media’s elements are a bit different because the primary audience of users of the service are not the customers. They are the input. Input is the existence of an audience whom advertisers want to market to. Output is the delivery of ads to that audience. The transaction is the fees paid by advertisers to the social media platform.<br/><br/>Whatever market and customer base you are targeting, be sure you know the input, output, and core business transaction that is your actual business. And realize the truth of the software industry:<br/><br/>The software is not your business. It is the key tool that enables your business. The transaction you identify in your business model is your actual business.<br/><br/>This matters because in order to make a sustainable software business, you need to understand what that business is. This will drive your decisions when it comes to marketing and sales, your market research and pricing, and your prioritization of engineering and other internal efforts.</p></div> </div><div class="timeline-item" data-index="3" data-id="d379093c-bcdc-44f9-960c-e3968f3dbd92"> <div class="date-title bg-dark font-light"> <div class="date-title-inner"> <div>10/21/2024</div> <div><strong>Building a positive environment for building software</strong></div>  </div> </div> <div class="content bg-light"><p>Lets start with why a positive environment for building the software matters. Prior posts explain that that the core business is everything other than the software, and the software is just a tool, but that should not diminish the importance put upon building a team who loves making that tool the best it can be.<br/><br/>A positive environment is good for all stakeholders in the software development process - members of the various product and engineering teams will enjoy their work and be satisfied making it a part of their life. The business in turn has a team they can rely on to fulfill the sustainability needs of the organization.<br/><br/><strong>So what is needed to build a positive environment?</strong><br/><br/>In short, you need to build a working environment that matches the personality of your team. In the software world, the teams tend to be comprised of members who are above average in intelligence, have a desire to be engaged with their work, and have a desire to create something new as a result of their work. They tend to want autonomy in their day-to-day work, to be trusted, and to be given a level of responsibility that matches their skills, as well as opportunity to grow their level of skills and be rewarded with increased responsibility, autonomy, and trust.<br/><br/>This is not the same as non-software environments. There are styles of leadership that work in other industries that will fail in software. Autocratic leadership is the one style that will fail almost 100% of the time. Servant leadership works for first line managers. Higher levels of management need to be focused on delegation, direction, and alignment.<br/><br/>My focus is on the product-focused areas of an organization. This includes:</p><ul><li>Engineers whose responsibility encompasses the coding and architecture of the product itself</li><li>Operational staff who keep the systems up and running</li><li>Support staff who communicate with the customers</li><li>Product management staff who research the market and decide what the product needs to do</li><li>Design staff responsibilie for how the customers and other stakeholder interact with the product.</li><li>QA staff who test the product and identify problems before changes are sent to the customers.</li><li>Leadership who keeps all those people in alignment.</li></ul><p><br/>Note the exclusions from this list:</p><ul><li>Executive leadership</li><li>Sales and Marketing</li><li>HR, accounting, and other internal corporate functions</li></ul><p><br/>I call out those exclusions because their satisfaction with their work environment is often not correlated with the satisfaction of the product team. I’ve seen happy product teams build amazing successful products even when other areas of the organization are miserable. Likewise, I’ve seen products fail when everyone else is happy, but the product team is miserable.<br/><br/><strong>So do you keep those teams happy?</strong><br/><br/>This is no single answer to this. As much as there will be similarities between people who gravitate to software work, we are all different people. The number one priority when determining how to structure your product team and all its processes, communications, and other aspects of its culture is simply to listen. Ask the team how they want to work. Let them work how they want. Let them experiment and self-govern to find their best working environments. Remove people from the team who are blockers to improving the health of the team. Hire people into the team who will fit the team culture they have built. Basically, let them work their way, not yours.<br/><br/>Even so, organizational leaders can put guardrails and requirements on the team. You can define what information you need to hear back from the team in order to understand their progress. You can give them the high-level goals that need to be accomplished. You can express the needs of the business to them. But it should be your goal to give them such requirements at as high of a level as possible, then trust them to handle the details. Your customers don’t care how the sausage is made, and really… neither should you.<br/><br/>At least, in theory. In reality, you do need to know where the team landed on their own organization. Ideally, a senior leader lets the team make decisions that align with the needs that have been communicated, then simply confirm their direction. But sometimes you need to referee. Sometimes business needs force specific internal processes. (Security needs, regulatory needs, etc.)<br/><br/>All that being said, there a few universal truths about a positive software culture:</p><ul><li>Do not rush the team. Some teams are fast, some are not, but if you push them faster than their natural pace, the quality of the product will suffer. Trust your team to know when to take shortcuts, when to put in time, when to make up for past shortcuts.</li><li>Everybody has an opinion about remote work. Build a team who agrees on whether or not they want to be in-person vs. remote. Mixing the two doesn’t work. This choice will exclude specific people from being on the team. Consider that a good thing - there is enough talent in this industry to go around, so if your otherwise perfect team member doesn’t want to match the rest of the team, that is a deal-killer. Hire people who match.</li><li>Do not micro-manage. Software people are rarely, if ever, the type of person who wants that.</li></ul><p><br/></p></div> </div><div class="timeline-item" data-index="4" data-id="9e436548-4d13-43c2-a40f-bc8e82ac15e4"> <div class="date-title bg-dark font-light"> <div class="date-title-inner"> <div>10/30/2024</div> <div><strong>What is “good” software?</strong></div>  </div> </div> <div class="content bg-light"><p>Good software does the following:</p><ul><li>Solves a problem - this can include any problem in business or your life, including recreational activities.</li><li>Is sustainable - It continues to work over time. The economics of creating and maintaining it are in balance with the fees charged for the software.</li><li>Is maintainable - It can be reasonably changed in order to adapt to changes in its ecosystems.</li><li>Is supported - The customers of the software can find the help they need when using it.</li><li>Is enjoyable - There needs to be an positive experience not only for the people who use it, but for the people who build, maintain, and support it.</li></ul><p><br/>You will note that my list of criteria for good software says nothing about the quality of the code or other technology used to build it. That is a deliberate omission. Good engineering does matter - it supports the points above. I exclude it as its own criteria to force the perspective that software engineering is a tool we use to build software, but is not a goal for its own sake.<br/><br/>Because this can be a contentious point, I want to use the tried-and-true analogy of comparing software dev to a house. Buying a house, in this case. If you saw a house that you loved and wanted to live in, but needed repairs, you would buy the house and fix the problems. But if you saw a house in perfect condition that you did not want to live in, you would not buy that hosue no matter how perfect its craftsmanship may be.<br/><br/>Software is the same - the craftsmanship does matter. But it is a secondary factor, not the primary goal. It makes it a sustainable place to enjoy spending time, only when and if everything already matches your needs.<br/><br/>Another deliberate exclusion from that list is AI. For similar reasons, but with how new AI is at the time I write this, I want to comment on where it fits in good software: Anywhere. AI is a tool, just like code. If you can solve a problem with AI, do so. But do it because it is the right tool for the job. Don&#x27;t add AI just because it is the latest innovation. That innovation must improve one of the points in the list above. The creation of software is about the result of all the combined elements, not the usage of any specific tool. </p></div> </div> </div>  </div>  </body>